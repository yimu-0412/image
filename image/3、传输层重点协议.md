* ## 一、UDP 协议

### 1、UDP 协议端格式
![UDP 协议端格式](https://raw.githubusercontent.com/yimu-0412/image/master/image/UDP%20%E5%8D%8F%E8%AE%AE%E7%AB%AF%E6%A0%BC%E5%BC%8F.png)
注：
1. 拼装报头的过程，其实就是所谓的“封装”
2. 16位UDP数据报的长度，表示整个数据报（UDP报头+UDP数据）的最大长度
3. UDP 使用2个字节的数据来表示，单位是字节
4. 2个字节表示范围 0 ~ 65535；一个UDP数据报，最大就是64KB。
5. 使用 UDP 来传输数据，一定要警惕大的报文，如果报文超过64KB，此时可能会丢失一部分数据。
6. 校验和更多的用处，其实就是“证伪”，一旦校验和出错，数据就会直接丢弃。

    1. 校验和具体是如何校验的？
        
        &emsp;&emsp;  实际使用的校验和算法比较多，其中比较常见的，crc，md5···

        &emsp;&emsp;  传输数据地时候，将数据和 crc 校验和一起传输给目标，接受方收到数据和 crc 校验和之后，会验证收到的数据是否正确。具体做法是将数据再进行计算 crc 检验和，如果计算的结果和收到的 crc 检验和结果一致，说明数据传输无误，反之数据传输错误！

        &emsp;&emsp;md5 本质是一个“非对称的哈希算法”，md5 算法本身本质就是针对数据进行一系列的数据变化。

        &emsp;&emsp;md5 算法的特性：

        
            1. 定长：无论输入的字符是多长，得到的md5值都是固定不变的！32位，64位128位····
        
            2. 分散：只要输入的字符串有变化，得到的md5值变化就会很大 

            3. 不可逆：通过原字符串，很容易得到md5；但是通过md5，理论上是无法恢复出原始的字符串！

        &emsp;&emsp;md5 应用场景：
        
            1. 作为 hash 算法（本来职责）；

            2. 作为校验和（很多场景，传输大文件，都会使用 md5 作为校验和）；

            3. 应用于一些密码学的场景

    2. UDP 的校验和是怎样工作的？
### 2、UDP 特点
1. 无连接

    只要知道对方的 IP 和端口号，就直接进行传输，不需要建立连接

2. 不可靠传输

    &emsp;&emsp;没有任何安全机制，发送端发送数据之后，如果因为网络故障或者其他原因无法发到对方，UDP 协议层也不会给应用层返回任何错误信息。

3. 面向数据报

    应用层交给UDP多长的报文，UDP原样发送，既不会拆分，也不会合并。
4. 半双工（只用接收缓冲区，无发送缓冲区）

    &emsp;&emsp;UDP没有真正意义上的 发送缓冲区。发送的数据会直接交给内核，由内核将数据传给网络层协议

    &emsp;&emsp;UDP具有接收缓冲区，但是这个接收缓冲区不能保证收到的UDP报的顺序和发送UDP报的顺序一致；如果缓冲区满了，再到达的UDP数据就会被丢弃；进行后续的传输动作；
5. 大小受限

    &emsp;&emsp;UDP协议首部中有一个16位的最大长度。也就是说一个UDP能传输的数据最大长度是64K（包含UDP首部）。
### 3、基于UDP的应用层协议
1. NFS ：网络文件系统
2. TFTP ：简单的文件传输协议
3. DHCP ：动态主机配置协议
4. BOOTP : 启动协议（用于无盘设备启动）
5. DNS ：域名解析协议 

## 二、TCP 协议 

&emsp;&emsp;TCP,即 Transmission Control Protocol，传输控制协议。对数据传输进行一个详细的控制。

### 1、TCP 协议端格式

&emsp;
![TCP协议端格式](https://raw.githubusercontent.com/yimu-0412/image/master/TCP%E5%8D%8F%E8%AE%AE%E7%AB%AF%E6%A0%BC%E5%BC%8F.png)

1. 源/目的端口:表示数据从哪个进程来，到哪个进程去。
2. 4位TCP报头长度：4个 bit 位，单位是 4个字节，4位首位长度值为1111 =》15，实际的首部长度就是15 * 4 = 60； 
15 * 4 = 60
3. 6位标志位：

    1. URG : 紧急指针是否有效
    2. ACK : 确认号是否有效
    3. PSH : 提示接收端应用程序立刻从 TCP 缓冲区把数据读走
    4. RST : 对方要求重新建立连接，把带有 RST 标识的称为复位报文段
    5. SYN : 请求建立连接，把携带 SYN 标识的称为同步报文段
    6. FIN : 通知对方，本端要关闭了，把携带 FIN 标识的称为结束报文段
4. 16位校验和：发送端填充，CRC 检验。接收端校验不通过，则认为数据有问题。此处的校验和不光包含 TCP 首部，也包含 TCP 数据部分。
5. 16位紧急指针：标识那部分数据是紧急数据。
6. 40字节的头部选项。

### 2、TCP 协议特性

1. 有连接
2. 可靠性传输（可靠性不等于安全性）
3. 面向字节流
4. 全双工
5. 大小不限

    &emsp;&emsp;对于字节流来说，可以简单的理解为，传输数据是基于IO流，流式数据的特征就是在IO流没有关闭的情况下，是无边界的数据，可以多次发送，也可以分开多次接收。

### 3、TCP 原理
&emsp;&emsp;TCP 对数据传输提供的管控机制，主要体现在两个方面：安全和效率。
这些机和线程的设计原则是：保证数据安全的前提下，尽可能提高传输效率。
#### 1.确认应答机制（安全机制）
&emsp;&emsp;发送方发送给接收方数据之后，接收方就会回应一个应答报文。如果发送方收到这个应答报文，那么就认为接收方已经收到了数据。

&emsp;&emsp;由于网络上的传输，充满不确定性，因此不能通过收到数据的顺序来确定逻辑。因此就需要给应答进行编号。TCP 的序号和确认序号，是以**字节**为单位进行编号的。

![TCP数据序列号](https://raw.githubusercontent.com/yimu-0412/image/master/TCP%E6%95%B0%E6%8D%AE%E5%BA%8F%E5%88%97%E5%8F%B7.png)

&emsp;&emsp;针对每个字节进行编号，依次进行累加。（TCP 序号的起始不一定是从1开始的）

1. **工作过程**：

![TCP 确认应答机制工作过程](https://raw.githubusercontent.com/yimu-0412/image/master/TCP%20%E7%A1%AE%E8%AE%A4%E5%BA%94%E7%AD%94%E6%9C%BA%E5%88%B6%E5%B7%A5%E4%BD%9C%E8%BF%87%E7%A8%8B.png)

&emsp;&emsp;解释：第一个请求,A 给 B 发送了1000个字节的数据，序号就是1~1000（假设从1开始编号），这就相当于是发送了一个数据报，这个数据报的序号是1，长度为1000；确认应答数据报，里面的确认序号是1001，意思就是1001之前的数据，B 已经收到了。也可以理解成，B 在向 A 索要1001开始的数据。序号1001~2000的数据传输和应答原理与上面的一致。

&emsp;&emsp;TCP 的核心是可靠性，可靠性的核心是确认应答。

2. **其它应用**：生产消费者模型


![生产消费者模型](https://raw.githubusercontent.com/yimu-0412/image/master/%E7%94%9F%E4%BA%A7%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B.png)

&emsp;&emsp;消息队列负责保存数据，但是消息对列的存储空间不是无限的。所以存的数据就需要定期淘汰。淘汰的原则就是：**如果一个数据没有被消费过，那么就不能被轻易的淘汰！**

&emsp;&emsp;如何判定这个数据是否被消费过？主要就是通过**确认应答**机制。

#### 2.超时重传机制（安全机制）

&emsp;&emsp;确认应答机制是数据传输比较顺利的情况。但是实际中，数据传输过程中可能会出现丢包的情况。一旦发生数据丢包，就要进入超时传送的机制。
1. 出现数据丢包的原因：

   1. 主机 A 发送数据给B之后，可能因为网络拥堵等原因，数据无法到达主机B；
   2. 主机 A 未收到B 发来的确认应答 

    ![超时重传机制的启动原因](https://raw.githubusercontent.com/yimu-0412/image/master/%E8%B6%85%E6%97%B6%E9%87%8D%E4%BC%A0%E6%9C%BA%E5%88%B6%E7%9A%84%E5%90%AF%E5%8A%A8%E5%8E%9F%E5%9B%A0.png)

2. 解决方法：如果主机A在一个特定时间间隔内没有收到B发来的确认应答，就会进行重发。因此主机 B 会收到很多重复的数据，TCP协议通过数据的序列号就可以达到去重的效果。
3. 超时的时间确定：动态计算这个最大超时时间。

    &emsp;&emsp;Linux 中 以500ms为一个单位进行控制，每次判定超时重发的超时时间都是500ms的整数倍。当累积到一定的重传次数，仍然得不到应答，TCP 就会认为网络对端主机出现异常，强制关闭连接。

#### 3.连接管理机制（安全机制）
&emsp;&emsp;在正常情况下，TCP 要经过三次握手建立连接，四次挥手断开连接。
1. “三次握手”建立连接


#### 4.滑动窗口（效率机制）
#### 5.流量机制（可靠机制）
#### 6.拥塞机制（可靠机制）
#### 7.延迟应答（效率机制）
#### 8.捎带应答（效率机制）
### 4、粘包问题
### 5、TCP 异常情况
### 6、基于 TCP 应用层协议
1. HTTP
2. HTTPS
3. SSH
4. TeInet
5. FTP
6. SMTP
7. 写 TCP 程序时自定义的应用层协议
